== Physical Plan ==
AdaptiveSparkPlan (9)
+- == Final Plan ==
   ResultQueryStage (6)
   +- * Sort (5)
      +- AQEShuffleRead (4)
         +- ShuffleQueryStage (3), Statistics(sizeInBytes=2.2 MiB, rowCount=4.19E+4)
            +- Exchange (2)
               +- * Scan ExistingRDD (1)
+- == Initial Plan ==
   Sort (8)
   +- Exchange (7)
      +- Scan ExistingRDD (1)


(1) Scan ExistingRDD [codegen id : 1]
Output [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: [x#97, y#98, pmi#99, count#100L], MapPartitionsRDD[91] at applySchemaToPythonRDD at NativeMethodAccessorImpl.java:0, ExistingRDD, UnknownPartitioning(0)

(2) Exchange
Input [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: rangepartitioning(pmi#99 DESC NULLS LAST, count#100L DESC NULLS LAST, x#97 ASC NULLS FIRST, y#98 ASC NULLS FIRST, 4), ENSURE_REQUIREMENTS, [plan_id=122]

(3) ShuffleQueryStage
Output [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: 0

(4) AQEShuffleRead
Input [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: coalesced

(5) Sort [codegen id : 2]
Input [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: [pmi#99 DESC NULLS LAST, count#100L DESC NULLS LAST, x#97 ASC NULLS FIRST, y#98 ASC NULLS FIRST], true, 0

(6) ResultQueryStage
Output [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: 1

(7) Exchange
Input [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: rangepartitioning(pmi#99 DESC NULLS LAST, count#100L DESC NULLS LAST, x#97 ASC NULLS FIRST, y#98 ASC NULLS FIRST, 4), ENSURE_REQUIREMENTS, [plan_id=115]

(8) Sort
Input [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: [pmi#99 DESC NULLS LAST, count#100L DESC NULLS LAST, x#97 ASC NULLS FIRST, y#98 ASC NULLS FIRST], true, 0

(9) AdaptiveSparkPlan
Output [4]: [x#97, y#98, pmi#99, count#100L]
Arguments: isFinalPlan=true


